=====================================================================
## pseudocode to push a node onto a stack implemented
## as a linked list
=====================================================================

PUSH (head, value):

instantiate "node" and SET "value"

IF head is NULL
	## handle case where list is empty
	SET head TO node
ELSE
	## set pointer to the beginning of the list
	SET curr_ptr TO head

	## advance to the end of the list
	WHILE "next" OF curr_ptr IS NOT NULL
		SET curr_ptr TO "next" OF curr_ptr
	END WHILE

	## insert the node at the end
	SET "next" OF curr_ptr TO node
ENDIF

return node


=====================================================================
## pseudocode to pop a node from a stack implemented as a linked list
=====================================================================

POP (head):

SET curr_ptr TO head
SET prev_ptr TO NULL

## continue looping until the end of the list is found
WHILE curr_ptr IS NOT NULL

	## if we are at the last node, pop it
	IF "next" of the curr_ptr IS NULL

		IF prev_ptr IS NOT NULL
			SET "next" OF prev_ptr TO "next" OF curr_ptr
		ELSE
			SET head TO "next" OF curr_ptr
		ENDIF

		RETURN curr_ptr
	ELSE

		## the criteria was not met, advance the pointers
		SET prev_ptr TO curr_ptr
		SET curr_ptr TO "next" of curr_ptr
	ENDIF

END WHILE

RETURN NULL


=====================================================================
## pseudocode to insert a node into a linked list such
## that the resulting list contains items in ascending order
=====================================================================

INSERT (head, value):

instantiate "node" and SET "value"

SET curr_ptr TO head
SET prev_ptr TO NULL

## continue looping until the end of the list is found
WHILE curr_ptr IS NOT NULL

	## if criteria is met, insert the node
	IF "number" of the curr_ptr is greater than "value"

		## set the value of the next pointer
		## in the node that is being inserted
		SET "next" OF node TO curr_ptr

		## point the previous node (or head)
		## to the node that is being inserted
		IF prev_ptr IS NOT NULL
			SET "next" OF prev_ptr TO node
		ELSE
			SET head TO node
		END IF

		## all done, return the node that was inserted
		RETURN node

	ELSE

		## the criteria was not met, advance the pointers
		SET prev_ptr TO curr_ptr
		SET curr_ptr TO "next" of curr_ptr

	ENDIF
END WHILE

## we've made it to the end of the loop without
## the criteria being met, insert the node at
## the end of the list.

## set the value of the next pointer in the node
## that is being inserted
SET "next" OF node TO curr_ptr

## point the previous node (or head) to the node
## that is being inserted
IF prev_ptr IS NOT NULL
	SET "next" OF prev_ptr TO node
ELSE
	SET head TO node
END IF

## all done, return the node that was inserted
RETURN node


=====================================================================
## psuedocode to delete the first node having the value specified
## from the linked list.  If no node is found, return null
=====================================================================

DELETE (head, value):

SET curr_ptr TO head
SET prev_ptr TO NULL


## continue looping until the end of the list is found
WHILE curr_ptr IS NOT NULL

	IF "number" of the curr_ptr IS EQUAL TO "value"

		## point the previous node (or head)
		## to the node after the one that is being deleted
		IF prev_ptr IS NOT NULL
			SET "next" OF prev_ptr TO "next" of curr_ptr
		ELSE
			SET head TO "next" of curr_ptr
		END IF

		RETURN curr_ptr
	ELSE

		## the criteria was not met, advance the pointers
		SET prev_ptr TO curr_ptr
		SET curr_ptr TO "next" of curr_ptr

	ENDIF

END WHILE

## we have finished looping and didn't find a match
RETURN NULL




